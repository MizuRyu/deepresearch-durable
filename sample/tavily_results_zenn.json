{
  "query": "durable functions ベストプラクティス zenn",
  "follow_up_questions": null,
  "answer": null,
  "images": [],
  "results": [
    {
      "url": "https://zenn.dev/microsoft/articles/durable-functions-monte-carlo",
      "title": "Durable Functionsでモンテカルロシミュレーションを実行する - Zenn",
      "content": "Durable Functionsは1回の実行をコントロールするオーケストレーター関数と、そのオーケストレーター関数から呼び出される複数のアクティビティ関数で構成",
      "score": 0.7557276,
      "raw_content": "![Microsoft (有志)](https://storage.googleapis.com/zenn-user-upload/avatar/c3d3b7b78f.jpeg)\n![](https://storage.googleapis.com/zenn-user-upload/avatar/c3d3b7b78f.jpeg)\n\n# Azure Functions - Durable Functionsでモンテカルロシミュレーションを実行する\n\n![](https://lh3.googleusercontent.com/a-/AOh14GiPkEjscFKUd5Wc7e2E7z_Fqn3RqgkW5Tcl3QipBg=s250-c)\n![](https://storage.googleapis.com/zenn-user-upload/topics/fe784bd781.png)\n![](https://zenn.dev/images/topic.png)\n![](https://static.zenn.studio/images/drawing/tech-icon.svg)\n\n## Durable Functions\n\nAWS LambdaやAzure Functionsに代表されるFaaSは、サーバーレスアーキテクチャの一つであり、スケール性に優れて多くの処理を並列実行できます。しかし、FaaSはイベントドリブンな処理をするために、1回あたりの処理にはタイムアウトが設けられていることが多く、長時間かかるタスクには向いていません。例えばAzure Functionsを使ってHTTPのWeb APIを作成する場合、リクエストから[230秒以上処理がかかる場合はタイムアウトしてしまいます](https://learn.microsoft.com/ja-jp/azure/azure-functions/functions-scale#timeout)。\n\nFaaSのスケール性や開発容易性（マネージド）を使いつつ、それらの課題を克服するために、AzureではAzure Functionsの拡張機能である**Durable Functions**を利用することで、タスクを並列実行したりチェーンでつなげたりしながら長時間にわたり実行することができます[[1]](#fn-69c1-1)。\n\n<https://learn.microsoft.com/ja-jp/azure/azure-functions/durable/>\n\n### ファンイン・ファンアウトパターン\n\nDurable Functionsには[さまざまな実行パターンが存在](https://learn.microsoft.com/ja-jp/azure/azure-functions/durable/durable-functions-overview?tabs=in-process%2Cnodejs-v3%2Cv1-model&pivots=csharp)しますが、中でもファンイン・ファンアウトパターンは、複数のタスクを並列実行し、その結果を集約するパターンです。例えば、複数のデータに対して同じ処理を並列で実行したり、その結果を集計するような処理に使われます。[[2]](#fn-69c1-2)\n\n![](https://res.cloudinary.com/zenn/image/fetch/s--X7Qi5SR0--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_1200/https://storage.googleapis.com/zenn-user-upload/deployed-images/35e6d2a3302cdc513d543832.png%3Fsha%3Dd6e8f0966c7573476bb79a249cb0036f2eb37540)\n\n![](https://res.cloudinary.com/zenn/image/fetch/s--X7Qi5SR0--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_1200/https://storage.googleapis.com/zenn-user-upload/deployed-images/35e6d2a3302cdc513d543832.png%3Fsha%3Dd6e8f0966c7573476bb79a249cb0036f2eb37540)\n\n## モンテカルロ法\n\nモンテカルロ法は乱数を用いて行うシミュレーション手法です。\n\n### 円周率の計算\n\nモンテカルロ法を学ぶための最も簡単なテーマとして「円周率の計算」があります。  \n半径1の円の中にランダムにいくつかの点を打ちます。この時に全ての点の数と円の中に入った数の比率は、円の面積と正方形の面積の比率に等しくなると考えることができます。\n\n![](https://res.cloudinary.com/zenn/image/fetch/s--aMUbD14I--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_1200/https://storage.googleapis.com/zenn-user-upload/deployed-images/185fb61c23cd9838b91d4791.png%3Fsha%3D0cc7d11e8d12a96551777a401caecdd41dc328dd)\n\n![](https://res.cloudinary.com/zenn/image/fetch/s--aMUbD14I--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_1200/https://storage.googleapis.com/zenn-user-upload/deployed-images/185fb61c23cd9838b91d4791.png%3Fsha%3D0cc7d11e8d12a96551777a401caecdd41dc328dd)\n\n上記の式を\\piについて解くと円周率は以下の式で表されます。\n\nなお、ランダムに打たれた点が円の中に入っているかの判定は中心から円周上の点の距離が必ず1になることと、ピタゴラスの定理を利用してxとyの2乗の和が1以下かどうかで判定します。  \n![](https://res.cloudinary.com/zenn/image/fetch/s--MoBuGlW7--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_1200/https://storage.googleapis.com/zenn-user-upload/deployed-images/375842ac09a33eedc8559a14.png%3Fsha%3D61eba03b7852e91469c88db3f9cfdd342df6b783)\n\n![](https://res.cloudinary.com/zenn/image/fetch/s--MoBuGlW7--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_1200/https://storage.googleapis.com/zenn-user-upload/deployed-images/375842ac09a33eedc8559a14.png%3Fsha%3D61eba03b7852e91469c88db3f9cfdd342df6b783)\n\n上記のシミュレーションを十分な数実行すれば、大数の法則によって真の円周率に収束するはずです。\n\n### 計算の流れ\n\nここで点を打つ回数を「サンプリング」と呼び、サンプリングによって円周率が求められる回数を「イテレーション」と呼びます。  \n1000サンプリングを10イテレーション行う場合、それぞれ1000個の点から導出された10個の円周率が求められます。  \nそして最後にそれらを平均することでより平準化した結果を求めることができます。\n\n![](https://res.cloudinary.com/zenn/image/fetch/s--hZjDWily--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_1200/https://storage.googleapis.com/zenn-user-upload/deployed-images/fb73f8b0a52ff6570e707998.png%3Fsha%3Db02dbf0b5c85cf4f8ce20db484c31873c120247c)\n\n![](https://res.cloudinary.com/zenn/image/fetch/s--hZjDWily--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_1200/https://storage.googleapis.com/zenn-user-upload/deployed-images/fb73f8b0a52ff6570e707998.png%3Fsha%3Db02dbf0b5c85cf4f8ce20db484c31873c120247c)\n\n## Durable Functionsでの実装\n\nここで話をDurable Functionsに戻します。  \nDurable Functionsのファンイン・ファンアウトパターンは処理を並列で多重実行するのに適しているため、モンテカルロシミュレーションにも適していると言えます。\n\nDurable Functionsは1回の実行をコントロールするオーケストレーター関数と、そのオーケストレーター関数から呼び出される複数のアクティビティ関数で構成されます。  \nまた、オーケストレーター関数を起動するためのHTTPトリガーやキュートリガーなど、外部要因によって起動されるスターター関数を作成することがほとんどです。  \n今回は1イテレーションをファンアウトし、1つのアクティビティ関数で1イテレーションを実行するような実装をしています。\n\n![](https://res.cloudinary.com/zenn/image/fetch/s--C3CYAaro--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_1200/https://storage.googleapis.com/zenn-user-upload/deployed-images/0d98a90d7271a04838f38ee9.png%3Fsha%3Ded6749cc5795730764b8b626d421f353c022450a)\n\n![](https://res.cloudinary.com/zenn/image/fetch/s--C3CYAaro--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_1200/https://storage.googleapis.com/zenn-user-upload/deployed-images/0d98a90d7271a04838f38ee9.png%3Fsha%3Ded6749cc5795730764b8b626d421f353c022450a)\n\n以下が主要なコードです。  \n共通クラスなど一部省略している部分がありますが、全体の完全なコードは[GitHub](https://github.com/07JP27/AzFuncMonteCarlo)で公開しています。\n\n`using Microsoft.Azure.Functions.Worker;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.DurableTask.Client;\nusing Microsoft.DurableTask;\nusing Microsoft.Azure.Functions.Worker.Http;\nnamespace AzFuncMonteCarlo\n{\npublic class Durable\n{\n[Function(\"durable\")]\npublic static async Task<HttpResponseData> Starter([HttpTrigger(AuthorizationLevel.Function, \"post\")] HttpRequestData req,[DurableClient] DurableTaskClient client)\n{\nConfig? config = await req.ReadFromJsonAsync<Config>();\nif (config is null) return req.CreateResponse(System.Net.HttpStatusCode.BadRequest);\nvar instanceId = await client.ScheduleNewOrchestrationInstanceAsync(nameof(Orchestration), config);\nreturn await client.CreateCheckStatusResponseAsync(req, instanceId);\n}\n[Function(nameof(Orchestration))]\npublic static async Task<Response> Orchestration([OrchestrationTrigger] TaskOrchestrationContext context)\n{\nConfig config = context.GetInput<Config>()!;\nvar response = new Response();\nvar startTime = context.CurrentUtcDateTime;\nList<Task<double>> parallelTasks = new List<Task<double>>();\nfor (int i = 0; i < config.TotalIterations; i++)\n{\nTask<double> task = context.CallActivityAsync<double>(nameof(IterationActivity), config.SamplingPerIteration);\nparallelTasks.Add(task);\n}\nvar iterations = (await Task.WhenAll(parallelTasks)).ToList();\nresponse.Iterations = iterations;\nvar endTime = context.CurrentUtcDateTime;\nvar duration = (endTime - startTime).TotalSeconds;\nresponse.DurationSecond = duration;\nresponse.SimulatedMedianValue = response.Iterations.Median();\nresponse.SimulatedAverageValue = response.Iterations.Average();\nresponse.SimulatedModeValue = response.Iterations.Mode();\nreturn response;\n}\n[Function(nameof(IterationActivity))]\npublic static double IterationActivity([ActivityTrigger] double samplingPerIteration)\n{\nvar inCircleCount = 0;\nfor (int j = 0; j < samplingPerIteration; j++)\n{\nvar (x, y) = Utility.GenerateRandomPoint();\nif (Utility.InCircle(x, y))\n{\ninCircleCount++;\n}\n}\n// 整数除算を避けるために、doubleにキャスト\nvar pi = 4 * ((double)inCircleCount / (double)samplingPerIteration);\nreturn pi;\n}\n}\n}`\n\nこのDurable Functionsに以下のようなリクエストを送ることで、モンテカルロシミュレーションを実行することができます。\n\n`{\n\"TotalIterations\": 10000,\n\"SamplingPerIteration\": 100000\n}`\n\nDurable Functionsでは、長時間かかる処理を実行する際、リクエストの完了までに時間がかかるため、結果をポーリングするためのエンドポイントを簡単に作成できます。このエンドポイントにリクエストを送信することで、処理の進捗を確認できます。  \nなお、Durable Functionsで長時間の実行が保証されるのはオーケストレーター関数のみです。そのため、スターター関数は処理実行リクエストを受け取った後、処理を開始し、状態確認用のレスポンスを返します。処理はその後、非同期で継続されます。\n\n`{\n\"id\": \"1a63ddxxxxxxx220f0d6eb\",\n\"purgeHistoryDeleteUri\": \"https://xxxxxxxxxxxxx.azurewebsites.net/runtime/webhooks/durabletask/instances/1a63ddxxxxxxx220f0d6eb?code=xxxxxxxxxxxxx=\",\n\"sendEventPostUri\": \"https://xxxxxxxxxxxxx.azurewebsites.net/runtime/webhooks/durabletask/instances/1a63ddxxxxxxx220f0d6eb/raiseEvent/{eventName}?code=xxxxxxxxxxxxx\",\n\"statusQueryGetUri\": \"https://xxxxxxxxxxxxx.azurewebsites.net/runtime/webhooks/durabletask/instances/1a63ddxxxxxxx220f0d6eb?code=xxxxxxxxxxxxx\",\n\"terminatePostUri\": \"https://xxxxxxxxxxxxx.azurewebsites.net/runtime/webhooks/durabletask/instances/1a63ddxxxxxxx220f0d6eb/terminate?reason={{text}}}&code=xxxxxxxxxxxxx\"\n}`\n\n今回の実装の場合、`statusQueryGetUri`にリクエストを送る(ポーリング)ことで処理の進捗を確認することができ、処理が完了すると以下のような結果が取得できます。\n\n`statusQueryGetUri`\n`{\n\"name\": \"Orchestration\",\n\"instanceId\": \"1a63ddxxxxxxx220f0d6eb\",\n\"runtimeStatus\": \"Completed\",\n\"input\": {\n\"SamplingPerIteration\": 100000,\n\"TotalIterations\": 10000\n},\n\"customStatus\": null,\n\"output\": {\n\"SimulatedMedianValue\": 3.1412,\n\"SimulatedAverageValue\": 3.141285119999971,\n\"SimulatedModeValue\": 3.1404,\n\"DurationSecond\": 315.2634636,\n\"Iterations\": [\n3.1076,\n...\n3.146\n]\n},\n\"createdTime\": \"2024-11-05T11:41:37Z\",\n\"lastUpdatedTime\": \"2024-11-05T11:47:05Z\"\n}`\n\n## 実行\n\n円周率を求めるモンテカルロシミュレーションがWeb APIとして作成できたので、実際にJupyter Notebookを使ってDurable Functionsを実行し、その結果を集計してみます。Notebookも[GitHub](https://github.com/07JP27/AzFuncMonteCarlo/blob/main/result_analyze.ipynb)に公開しています。\n\nモンテカルロシミュレーションでは試行回数が多ければ多いほどより正確な値に近似できると考えられますが、実際にはコンピューティングリソースには限りがあるためサンプリング数を無限にすることはできず、ちょうど良いサンプリング数を見つける必要があります。  \nそこでまずはイテレーションを200回に固定し、サンプリング数を変数としてシミュレーションを実行してみます。円周率は既知の値であるため、補助的に赤の直線で示しています。  \n![](https://res.cloudinary.com/zenn/image/fetch/s--kCMRQi8d--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_1200/https://storage.googleapis.com/zenn-user-upload/deployed-images/e77166f2ba89eafedf76fd54.png%3Fsha%3Ddcc309bb88571b008452b9160b1302b7d5e4277d)\n\n![](https://res.cloudinary.com/zenn/image/fetch/s--kCMRQi8d--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_1200/https://storage.googleapis.com/zenn-user-upload/deployed-images/e77166f2ba89eafedf76fd54.png%3Fsha%3Ddcc309bb88571b008452b9160b1302b7d5e4277d)\n\nこの結果から1イテレーションあたりのサンプリング数は100000回程度であれば（もちろんどれくらい正確に求めるかは目的によりますが）十分な精度で求めることができることが予想されます。\n\nサンプリング数の目処がついたので、次にサンプリング数を100000回に固定し、イテレーション数を変数としてシミュレーションを実行してみます。  \n![](https://res.cloudinary.com/zenn/image/fetch/s--Eu-XkA7u--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_1200/https://storage.googleapis.com/zenn-user-upload/deployed-images/bd1462cf26d0b19229140594.png%3Fsha%3Daa2fd3c1a616a4cd057c9c9e16135e3fb161f8ba)\n\n![](https://res.cloudinary.com/zenn/image/fetch/s--Eu-XkA7u--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_1200/https://storage.googleapis.com/zenn-user-upload/deployed-images/bd1462cf26d0b19229140594.png%3Fsha%3Daa2fd3c1a616a4cd057c9c9e16135e3fb161f8ba)\n\nイテレーションが10回程度では収束が見られませんが、100回程度で山ができ始め、10000回程度で正規分布に近づいていることがわかります。\n\nここまでの実験から、ある程度の精度が期待できる100000サンプリング10000イテレーションで求められた結果は以下の通りです。  \n![](https://res.cloudinary.com/zenn/image/fetch/s--66gXr6ud--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_1200/https://storage.googleapis.com/zenn-user-upload/deployed-images/bb4cc8a9ec47e0a9a0cdc648.png%3Fsha%3Df66bf649a036204bb11d3b987341b6b4f0530866)\n\n![](https://res.cloudinary.com/zenn/image/fetch/s--66gXr6ud--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_1200/https://storage.googleapis.com/zenn-user-upload/deployed-images/bb4cc8a9ec47e0a9a0cdc648.png%3Fsha%3Df66bf649a036204bb11d3b987341b6b4f0530866)\n\n実用的に使われる円周率が3.14程度までであるとことを考えると、十分実用的な結果を求めることができたと言えます。\n\n## まとめ\n\nDurable Functionsを使うことでこんなことができます、という紹介でした。  \nファンイン・ファンアウトパターンを使ってモンテカルロシミュレーションを実行することで、長時間かかる処理を並列で実行することができました。  \nまた、サンプリング数やイテレーション数を変数としてシミュレーションを実行することで、円周率を求める際の精度や収束を確認することができました。\n\n実際にはDurable Functionsはチェックポイントを使用して状態を保存し、そこから処理を再開することで長時間の実行を可能にしています。また、この動作はアクティビティ関数やスターター関数には適用されません。詳しくは[こちら](https://learn.microsoft.com/ja-jp/azure/azure-functions/durable/durable-functions-orchestrations?tabs=csharp-inproc#next-steps) [↩︎](#fnref-69c1-1)\n\n最近よくある用途として、生成AIのRAGに使うためのデータのチャンク分割処理において、分割した各チャンクを並列でクレンジング処理するような用途に使われています。 [↩︎](#fnref-69c1-2)\n\n![](https://storage.googleapis.com/zenn-user-upload/avatar/c3d3b7b78f.jpeg)\n\n**📢 参加登録受付中!! Microsoft Cloud & AI Bootcamp**  \n7 月 22 日（火）〜25 日（金）開催\n\n4 日間にわるオンライン イベント「Microsoft Cloud & AI Bootcamp」を開催します。  \n本イベントでは、今注目されている課題と最先端のソリューションを厳選し、戦略立案から安全かつスケーラブルな実行に至るまで、AI 活用を加速させるための実践的な知識とスキルを習得いただけます。\n\n詳細・申込はこちら👉 <https://www.microsoft.com/ja-jp/cloudandaibootcamp/>\n\n![Junpei Tsuchida（07JP27）](https://lh3.googleusercontent.com/a-/AOh14GiPkEjscFKUd5Wc7e2E7z_Fqn3RqgkW5Tcl3QipBg=s250-c)\n\nAzure engineer @ Microsoft Japan / Azure大好き人間 / 言語は静的型付け言語が好き。特にC# / JDLA E資格 2019#2\n\n![Microsoft (有志)](https://storage.googleapis.com/zenn-user-upload/avatar/c3d3b7b78f.jpeg)\n\nMicrosoft Azureをはじめとする最新技術情報をお届けします。\n※このPublicationは日本マイクロソフトまたは米Microsoft所属社員による個人の見解であり、所属する組織の公式見解ではありません。\n※Publicationに参加希望の社員は @07JP27までご連絡ください。\n\n### Discussion\n\n![](https://static.zenn.studio/images/drawing/discussion.png)\n![Junpei Tsuchida（07JP27）](https://lh3.googleusercontent.com/a-/AOh14GiPkEjscFKUd5Wc7e2E7z_Fqn3RqgkW5Tcl3QipBg=s250-c)\n\nAzure engineer @ Microsoft Japan / Azure大好き人間 / 言語は静的型付け言語が好き。特にC# / JDLA E資格 2019#2\n\nエンジニアのための  \n情報共有コミュニティ\n\n#### About\n\n#### Guides\n\n#### Links\n\n#### Legal"
    }
  ],
  "response_time": 4.71
}